# Readings

## Domain-Driven Design: Tackling Complexity in the Hearth of Software (ISBN: 978-0-321-12521-5)

Chapter 7: Using the Language: An Extended Example
- Model refinement, design, implementation are iterative processes and should go together.
- Objects should be entities, when they have identity, must be distinguishable, are not interchangeable, are not unique based on properties.
IDs can be domain-specific (Social Security Number), or generated by system (UUID). They can be the combination of different properties.
They can also be borrowed from aggregate roots in case of one-to-one relationship.
- Objects should be value objects when they have no history or continuity, can be shared among other objects.
Value objects can be usually replaced by other objects.
- Bidirectional or circular associations are complex: changes in one object must be reflected in another.
They can be replaced with database lookup, but it is not efficient in case of frequent queries.
Such queries should answer specific question.
- Entities should be roots of aggregate when they are shared by many objects, are meaningful apart from other objects.
- Entities should be in boundaries of other aggregates when they are not required to be accessed globally, have derived identities.
- Repositories should be usually limited to root aggregates. Repositories should be created if user needs to access or save objects.
- When entities need to be copied, they can usually be created in self-contained copy factory method (Prototype pattern).
Aggregate roots should be copied carefully: Entity Objects should be usually created empty anew and assigned to a copy.
References to other entities should be copied. New ID should be assigned. 
- Entities constructor should get an ID. Factories can deliver it. Non identifying attributes of entities can usually be added later.
- When base class of entity is derived, creating factory methods for each implementation in a super class can be convenient.
- Module names should be consistent to the ubiquitous language.
- When the external system should be connected to application, it should be abstracted with new terms in a domain.
A service covering specific language of the external system should be created (anti corruption layer). 
- But the application layer should not contain the business rules of integration: service methods should use our domain language.
- Performance problems with interaction with external systems may be optimized using caching.
But there is a cost: complicated design, refreshing duplicated data.

Chapter 8: Breakthrough
- Continuous refactoring of the model should be regular and iterative. It usually provides little gains with little effort.
- Refactoring should be handled with ubiquitous language in mind, it should help changing it, or align the model to it.
- But continuous refactoring also is preparing a stage for huge breakthroughs, a large change in the model, sometimes
flipping it around, to better reflect the language.
- Opportunities for such huge changes require modest refactoring, helping to better understand the domain.
- Such opportunities are usually scary, as the changes are huge. They also cannot be planned. 
Sometimes they're performed under the time pressure. But they're worth the effort, as they are eyes-opening.
They also provide opportunities for further improvements.
- Sometimes after such breakthroughs other incorrectly modeled areas reveal themselves.

Chapter 9: Making implicit concepts explicit
- A deep model is powerful as it contains basic concepts and abstractions, expresses essential knowledge.
- If domain experts or users use term, which is not present in the design, it should be a warning.
It's even worse if when both domain experts and developers use terms not present in the design.
If some vocabulary is missing in the domain, it's time to enhance it.
- When searching for a place to update the model, the choice should be the most awkward part in the model,
which is the most complicated one and brings the most trouble when adding new features.
- Sometimes different domain experts see things differently, use different terms. Even the same person can communicate in inconsistent way.
To deal with it, to have a better understanding, developers could read a book about the domain.
But still they should have conversations with domain experts.
- Designers should not be constrained with their own ideas. Model should evolve.
They should enhance the model constantly, try things, checking if they work or not.
Even small refactoring leaves the model in a more understandable shape.
- Constraints and processes are part of the model, that are not intuitive to discover.
Domain processes are easy to discover: is it a process specific to a domain, or to a software itself?
- Rules can be expressed as predicates. Rules sometimes do not fit the concept of entity or value object.
But defining them outside the domain is even worse.
- Specifications can be used for several purposes: validation, querying (as a criteria), objects creation (as the definition of shape of the requested object).

Chapter 10: Supple design
- Before a program serves customers, it should serve developers. The design must be pleasant to work with, inviting to change.
It should be simple. But making it simple is not easy.
- If the interface doesn't tell client programmers what it does, he has to check the internals. This reduces encapsulation.
Names of classes and methods should clearly communicate what they do. They should use the ubiquitous language.
TDD helps to understand client programmers' perspective.
- Commands and queries (functions) should be segregated to communicate their purpose. Queries do not change internal state of a system.
As much logic as possible should be covered by functions. But commands cannot be entirely avoided. Commands should not return the domain information.
But there are alternative ways, like working on the value objects, which are immutable.
- Assertions (post-conditions) help predict the side effects. If the programming language doesn't support them, they should be defined as unit tests.
- When the model contains of large monolithic objects, it's hard to understand and has tendency for duplication.
On the other hand, too much granularity introduces complexity. The model should contain of cohesive, loosely coupled units of functionality.
Interface should use meaningful statements in ubiquitous language.
- Low coupling is fundamental. It's important to eliminate unnecessary dependencies between objects whenever possible.
- Dependencies in the model are not bad at all. But the concepts should not be mixed in interfaces: returned types should be the same as arguments.
- Declarative design is concept of generating a program according to specification. It could be achieved e.i. by reflection.
It's a holy grail of DDD. It has the greatest value, when framework can generate most error-prone logic of the system, like ORM.
- DSLs: Shipping program may contain cargos and routes. But the implementation could be delivered by a library.
This is a way to deliver the strongest connection with ubiquitous language. But on the other hand, such code could be hard to refactor.
- Declarative predicates can be connected with ANDs, ORs, NOTs.
- When making the design more supple, it's impossible to tackle the entire model at once. 
Making significant change in part of the system is more valuable than thin change in the entire system.

## Clean Coder (ISBN: 978-0-13-708107-3)

Chapter 8: Testing strategies
- Whenever a QA finds a bug, the development team should react with panic and take steps to prevent it in the future.
- QAs should be part of the team. QAs and developers should work together to ensure the quality of a system.
- The responsibility of QA should be working with business analysts to create acceptance tests - system specification,
but also performing exploratory test, to validate actual system behavior and report misbehaviour.
- Test pyramid:
  - **Unit tests** are created by programmers for programmers using the language the system is build.
  The coverage should be close to 100%.
  - While components encapsulate some business rules, **component test** verify them in isolation from other components.
  They are part of the acceptance tests, should be created by QAs together with business analysts.
  They should focus on happy paths with some obvious corner cases.
  - **Integration tests** verify how well components communicate with each other. They don't test business rules.
  They should be created by system architect. Testing performance and throughput should not be a surprise here.
  They are usually excluded from CI builds (run daily, for example).
  - **System tests** are testing the entire integrated system. They're not testing business rules, but rather system construction.
  They should be created by system architect. We should expect performance and throughput tests here.
  Should be run infrequently.
  - **Exploratory tests** should not be automated. They rely on humans creativity to check how the system withstands interactions with humans.

Chapter 9: Time management
- It's required to maintain a strict daily time management discipline to benefit from the working time.
- Meetings are necessary, but they are a waste of time. Decline the meetings when your presence is not crucial.
Leave the meeting, when it doesn't go as expected. Each meeting should have an agenda, when it doesn't - decline,
when the discussion is not going according to the agenda - leave.
- Daily stand-ups should not take more than 1 minute for a person to answer three questions:
what I did yesterday, what I will do today, what stands on my way.
- Iteration planning should not take more than 5% of the entire iteration time. Items should already be estimated, 
business value should already be assessed, acceptance tests should be created.
- Retrospective and demo should not take long: 20 minutes for retrospective, 25 minutes for demo.
- When the argument cannot be solved in 5 minutes, it cannot be solved with arguing. Good argument requires data.
It should not be solved with a strength of will. Passive aggression is the most unprofessional think: when you agree upon something, you have to be engaged. 
- You can't stay fully focused for the entire day. Use your focus time for complicated tasks, take less demanding tasks when unfocused.
Focus requires sleep hygiene. Coffee may help, but it results in disruption. Sometimes you just have to recharge (have a 1-hour walk). 
Physical activity helps. When unfocused, get inspired by the creativity of other people.
- Avoidance is a behavior of postponing high-priority tasks. Priority inversion comes in, which
is a temptation to focus on less important tasks. Such behavior is unprofessional.
- Tomato technique is a way to divide the working time into blocks. Defend your slots, disruptions may wait until the timeslot is finished.
After dealing with them, take 5 minutes break and start a new slot.
- Blind alleys are incorrect technical decisions you are afraid to revert. If you find yourself in a hole, stop digging.
- Mess comes in when you start developing code without taking proper care of it - there will never be a better moment for cleaning up, than now.


# Projects

## ACTracker

- [API for generating dashboard grouped by day](https://github.com/marcinciapa/actracker-api/pull/51) was exposed.
[Generating chart grouped by day](https://github.com/marcinciapa/actracker-ui/pull/24) was implemented in UI.
- Generating dashboards by tag was [replaced](https://github.com/marcinciapa/actracker-api/pull/52) by Java-based generator.
- Sorting activities was [added to API](https://github.com/marcinciapa/actracker-api/pull/53).
Start time, descending, was [implemented](https://github.com/marcinciapa/actracker-ui/pull/25) as a default sort option in UI.
- Daily chart generation was [implemented in Backend](https://github.com/marcinciapa/actracker-api/pull/55).
- Filtering activities by date range and tags was introduced in [actracker-api](https://github.com/marcinciapa/actracker-api/pull/56) and [actracker-ui](https://github.com/marcinciapa/actracker-ui/pull/26).
- Filtering dashboard data by tags was added to [API](https://github.com/marcinciapa/actracker-api/pull/57) and [UI](https://github.com/marcinciapa/actracker-ui/pull/27).
- Data drill-down in dashboards was [implemented](https://github.com/marcinciapa/actracker-ui/pull/29).
- Supported list of tags in chart was added in [UI](https://github.com/marcinciapa/actracker-ui/pull/31) and [API](https://github.com/marcinciapa/actracker-api/pull/60).
- Support for weekly and monthly dashboards was added in [API](https://github.com/marcinciapa/actracker-api/pull/63) and [UI](https://github.com/marcinciapa/actracker-ui/pull/32).
- Metrics were added to tags. [API](https://github.com/marcinciapa/actracker-api/pull/70) for metrics was exposed,
adding metrics in [UI](https://github.com/marcinciapa/actracker-ui/pull/38) was implemented.
- Using metric values in Activities was implemented. 
[API](https://github.com/marcinciapa/actracker-api/pull/72) was exposed, [UI](https://github.com/marcinciapa/actracker-ui/pull/40) was aligned.