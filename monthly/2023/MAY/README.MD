# Readings

## Domain-Driven Design: Tackling Complexity in the Hearth of Software (ISBN: 978-0-321-12521-5)

Chapter 7: Using the Language: An Extended Example
- Model refinement, design, implementation are iterative processes and should go together.
- Objects should be entities, when they have identity, must be distinguishable, are not interchangeable, are not unique based on properties.
IDs can be domain-specific (Social Security Number), or generated by system (UUID). They can be the combination of different properties.
They can also be borrowed from aggregate roots in case of one-to-one relationship.
- Objects should be value objects when they have no history or continuity, can be shared among other objects.
Value objects can be usually replaced by other objects.
- Bidirectional or circular associations are complex: changes in one object must be reflected in another.
They can be replaced with database lookup, but it is not efficient in case of frequent queries.
Such queries should answer specific question.
- Entities should be roots of aggregate when they are shared by many objects, are meaningful apart from other objects.
- Entities should be in boundaries of other aggregates when they are not required to be accessed globally, have derived identities.
- Repositories should be usually limited to root aggregates. Repositories should be created if user needs to access or save objects.
- When entities need to be copied, they can usually be created in self-contained copy factory method (Prototype pattern).
Aggregate roots should be copied carefully: Entity Objects should be usually created empty anew and assigned to a copy.
References to other entities should be copied. New ID should be assigned. 
- Entities constructor should get an ID. Factories can deliver it. Non identifying attributes of entities can usually be added later.
- When base class of entity is derived, creating factory methods for each implementation in a super class can be convenient.
- Module names should be consistent to the ubiquitous language.
- When the external system should be connected to application, it should be abstracted with new terms in a domain.
A service covering specific language of the external system should be created (anti corruption layer). 
- But the application layer should not contain the business rules of integration: service methods should use our domain language.
- Performance problems with interaction with external systems may be optimized using caching.
But there is a cost: complicated design, refreshing duplicated data.

Chapter 8: Breakthrough
- Continuous refactoring of the model should be regular and iterative. It usually provides little gains with little effort.
- Refactoring should be handled with ubiquitous language in mind, it should help changing it, or align the model to it.
- But continuous refactoring also is preparing a stage for huge breakthroughs, a large change in the model, sometimes
flipping it around, to better reflect the language.
- Opportunities for such huge changes require modest refactoring, helping to better understand the domain.
- Such opportunities are usually scary, as the changes are huge. They also cannot be planned. 
Sometimes they're performed under the time pressure. But they're worth the effort, as they are eyes-opening.
They also provide opportunities for further improvements.
- Sometimes after such breakthroughs other incorrectly modeled areas reveal themselves.

Chapter 9: Making implicit concepts explicit
- A deep model is powerful as it contains basic concepts and abstractions, expresses essential knowledge.
- If domain experts or users use term, which is not present in the design, it should be a warning.
It's even worse if when both domain experts and developers use terms not present in the design.
If some vocabulary is missing in the domain, it's time to enhance it.
- When searching for a place to update the model, the choice should be the most awkward part in the model,
which is the most complicated one and brings the most trouble when adding new features.
- Sometimes different domain experts see things differently, use different terms. Even the same person can communicate in inconsistent way.
To deal with it, to have a better understanding, developers could read a book about the domain.
But still they should have conversations with domain experts.
- Designers should not be constrained with their own ideas. Model should evolve.
They should enhance the model constantly, try things, checking if they work or not.
Even small refactoring leaves the model in a more understandable shape.
- Constraints and processes are part of the model, that are not intuitive to discover.
Domain processes are easy to discover: is it a process specific to a domain, or to a software itself?
- Rules can be expressed as predicates. Rules sometimes do not fit the concept of entity or value object.
But defining them outside the domain is even worse.
- Specifications can be used for several purposes: validation, querying (as a criteria), objects creation (as the definition of shape of the requested object).


# Projects

## ACTracker

- [API for generating dashboard grouped by day](https://github.com/marcinciapa/actracker-api/pull/51) was exposed.
[Generating chart grouped by day](https://github.com/marcinciapa/actracker-ui/pull/24) was implemented in UI.
- Generating dashboards by tag was [replaced](https://github.com/marcinciapa/actracker-api/pull/52) by Java-based generator.
- Sorting activities was [added to API](https://github.com/marcinciapa/actracker-api/pull/53).
Start time, descending, was [implemented](https://github.com/marcinciapa/actracker-ui/pull/25) as a default sort option in UI.
- Daily chart generation was [implemented in Backend](https://github.com/marcinciapa/actracker-api/pull/55).
- Filtering activities by date range and tags was introduced in [actracker-api](https://github.com/marcinciapa/actracker-api/pull/56) and [actracker-ui](https://github.com/marcinciapa/actracker-ui/pull/26).
- Filtering dashboard data by tags was added to [API](https://github.com/marcinciapa/actracker-api/pull/57) and [UI](https://github.com/marcinciapa/actracker-ui/pull/27).
- Data drill-down in dashboards was [implemented](https://github.com/marcinciapa/actracker-ui/pull/29).
- Supported list of tags in chart was added in [UI](https://github.com/marcinciapa/actracker-ui/pull/31) and [API](https://github.com/marcinciapa/actracker-api/pull/60).
- Support for weekly and monthly dashboards was added in [API](https://github.com/marcinciapa/actracker-api/pull/63) and [UI](https://github.com/marcinciapa/actracker-ui/pull/32).
- Metrics were added to tags. [API](https://github.com/marcinciapa/actracker-api/pull/70) for metrics was exposed,
adding metrics in [UI](https://github.com/marcinciapa/actracker-ui/pull/38) was implemented.