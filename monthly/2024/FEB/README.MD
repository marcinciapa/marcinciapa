# Readings

## Optimizing Java. Practical Techniques for Improving JVM Application Performance (ISBN: 978-1-49-203927-3)

## Modern Software Engineering: Doing What Works to Build Better Software Faster (ISBN: 978-0-13-731491-1)

2 What is Engineering?

- Software isn't bridge building, but there are similarities. The source of confusion is the misconception about bridge
  building. The most important discussion should be between production engineering and design engineering.
- Waterfall is an equivalent of inventing production lines for software. But mass production is not a good pattern for
  software. In heart of software engineering should be discovery, learning and experimentation.
- The advantage of software over any other engineering professions is the ability of iterating over the outcome. It's
  impossible to quickly iterate over a product which is physical. In software our computer simulations of a problem
  __is__ our product, it's easier to change. However, despite this, scientific approach to software development is not
  common.
- Formal methods are not practical in the area of software development. Creating software is complex enough, creating
  code which proves itself correct is even harder. Mathematical approach is limiting. Math doesn't replace testing and
  experimentation. We should apply mathematical thinking when suitable, but take data-driven, pragmatic, experimental
  approach to learning. In comparison to other engineering areas, testing software is testing our product itself, not 
  the simulation of it.
- If our engineering practices don't allow us to move faster, they don't qualify as engineering. We should use our
  experience, empirical learning, discovery and imagining how things could possibly go wrong. While creating a system,
  it should run first, even if it doesn't do anything useful.
- Engineering is applied science. While thinking about software engineering, we should consider everything what
  influences making software: process, tools, culture.
- There are differences between craft and engineering, in context of software it's __precision__ and __scalability__.
  Approaches relaying on human capabilities are limited to human capabilities. An engineer can create machines which
  create smaller and more precise things comparing to a craftsman. Craft-based solutions are not scalable to the same
  level as engineering-based solutions.
- The fundamental nature of software engineering is that it's not about production, it's about design. We should pursue
  to improve our management of complexity, including measuring with a certain level of precision. We should use accurate
  measurements to prevent problems upfront instead of waiting for bad things to happen to diagnose a problem.
- Software craftsmanship is needed, but it's not enough. It has limitations. Focus on skill, creativity, freedom to
  innovate, apprentice schemes is important, but it's not limited to craftsmanship. Engineers should make use of all of
  these qualities. The motivation for engineers should be to find elegant, efficient solutions to complex problems.
- Engineering decisions should base on rational criteria (like strength at a certain temperature, economic factor). But
  they should still be experimental, iterative, empirical. As engineers, we should make decisions based on evidence,
  then test the ideas and check if they work.
- Engineering means constant optimizations and trade-offs: system more secure or easier to use, more distributed or
  integrating quicker, more people working on a project to speed development up or reducing the overhead of
  communications.
- In the era of serverless computing we should probably focus on denormalized data stores and eventual consistency
  rather than minimizing storage with normalized data. Such approach improves modularity.

# Projects

## ACTracker

# Tutorials

[Spring Security tutorial](https://github.com/marcinciapa/tutorials/pull/32)
[Spring Boot 3 + Spring Security 6 tutorial](https://github.com/marcinciapa/tutorials/pull/33)