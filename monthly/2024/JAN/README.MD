# Readings

## Optimizing Java. Practical Techniques for Improving JVM Application Performance (ISBN: 978-1-49-203927-3)

Chapter 11. Java Language Performance Techniques

- JVM is able to optimize non-optimal code. However, the design of the code is the biggest potential performance
  bottleneck. It's not wise to use data structures without the knowledge how they behave.
- In Java there are two main types of containers: sequential, where objects are accessed by numerical index, and
  associative, where objects themselves are used to determine where they should be stored in a collection. In either way
  references are stored in containers rather than objects themselves.
- The main types of list are __ArrayList__ and __LinkedList__.
    - ArrayList stores objects in the internal array (initially, by default, of size of 10). When it becomes full, new
      larger array must be allocated. It provides a convenience of not knowing ahead what the size of the list will be,
      but also an overhead related to resizing. It's possible and wise to set the capacity upfront, whenever the size of
      list is known.
    - LinkedList's advantage is O(1) appending.
    - The decision whether to use ArrayList of LinkedList should depend on the pattern of access. Inserting to both
      lists is O(1). Adding at an index to ArrayList requires all following elements to be shifted. Getting any element
      from ArrayList is O(1), while LinkedList requires navigating from the beginning. Usually ArrayList is recommended,
      unless specific behavior of LinkedList is desired (appending to the beginning/end of the list).
    - _Collections_ class exposes method _synchronizedList()_, which wraps List method invocations in a _synchronized_
      block.
- The main types of map are __HashMap__, __LinkedHashMap__ and __TreeMap__.
    - Two factors impact the performance of HashMap: __initialCapacity__ (current number of buckets, defaults to 16) and
      __loadFactor__ (how full the hash table is allowed before the capacity is increased, defaults to 0.75). Increasing
      the capacity (twice for JVM) requires rehashing, resulting in performance impact.
    - It's recommended to set the initialCapacity if it's known upfront. It reduces the overhead of automatic rehashing.
      Increasing the loadFactor also reduces rehashing, but makes access slower as map becomes fuller.
    - HashMap provides O(1) _get()_ and _put()_ times. Iterating may be costly and is impacted by initialCapacity and
      loadFactor.
    - When buckets become large there is an additional overhead of searching in them: elements are stored as LinkedList.
      Once buckets extends _TREEIFY_THRESHOLD_ it is converted into _TreeNodes_. The disadvantage of maintaining
      _TreeNodes_ is that their size is twice the size of a list nodes.
    - _LinkedHashMap_, a subclass of _HashMap_ maintains the insertion order. It's less costly than using _TreeMap_. The
      need of using _LinkedHashMap_ is low as in Maps order rarely matters.
    - _TreeMap_ is a red-black tree implementation - a binary tree with additional metadata (coloring) preventing trees
      from becoming unbalanced. TreeMap offers quick access to a submap, it's efficient for partitioning the data. It
      offers log(n) performance for _get()_, _put()_, _containsKey()_ and _remove()_ operations.
- The main types of set are __HashSet__, __LinkedHashSet__, __TreeSet__. They are implemented on top of Map equivalents,
  storing elements as keys and an object placeholder as value.
    - HashSet has O(1) insertion, removal and contains operation time, doesn't maintain an ordering of elements.
    - LinkedHashSet maintains an ordering of elements, performance depends on __initialCapacity__ and __loadFactor__.
    - TreeSet is implemented in similar way to TreeMap, preserves the natural ordering of elements. It offers log(n)
      performance for insertion, removal and contains operations. For range-based or ordering operations TreeSet is
      efficient.
- Domain objects often cause problems like memory leaks. `jmap -histo` provides a quick insight into the state of Java
  heap for diagnosing them. If domain objects appear in the top 30 entities generated by _jmap_, it's a possible sign of
  memory leak. Leaking domain objects also cause _all generations effect_. When leaking, they live long enough to become
  Tenured and will show up with all possible values for the generational count.
- _finalize()_ in Java was provided for automatic cleanup and resources release when an object is destroyed. It's a
  no-op by default and should remain that way. Objects overriding _finalize()_ are treated specially by the garbage
  collector. They require GC to run again to collect the data, persist for one extra GC cycle, which can be particularly
  painful for Tenured objects. Additionally, when exception is thrown in _finalize()_ method, it's ignored. Finalization
  may contain blocking operations. As JVM creates a thread to run _finalize()_, a significant overhead may occur.
  Oracle's recommendation is to avoid finalization.

# Projects

## ACTracker

- GET API for entities was [introduced](https://github.com/marcinciapa/actracker-api/pull/161) in actracker-api.

# Tutorials

- Microservices and Distributed Systems: [Bootstrap with Maven](https://github.com/marcinciapa/tutorials/pull/10)
- Microservices and Distributed Systems: [Your First Microservice](https://github.com/marcinciapa/tutorials/pull/11)
- Microservices and Distributed
  Systems: [Microservice Communication via HTTP](https://github.com/marcinciapa/tutorials/pull/12)
- Microservices and Distributed Systems: [Open Feign](https://github.com/marcinciapa/tutorials/pull/14)
- Microservices and Distributed Systems: [Exercise](https://github.com/marcinciapa/tutorials/pull/16)