# Readings

## Optimizing Java. Practical Techniques for Improving JVM Application Performance (ISBN: 978-1-49-203927-3)

Chapter 11. Java Language Performance Techniques

- JVM is able to optimize non-optimal code. However, the design of the code is the biggest potential performance
  bottleneck. It's not wise to use data structures without the knowledge how they behave.
- In Java there are two main types of containers: sequential, where objects are accessed by numerical index, and
  associative, where objects themselves are used to determine where they should be stored in a collection. In either way
  references are stored in containers rather than objects themselves.
- The main types of list are __ArrayList__ and __LinkedList__.
    - _ArrayList_ stores objects in the internal array (initially, by default, of size of 10). When it becomes full, new
      larger array must be allocated. It provides a convenience of not knowing ahead what the size of the list will be,
      but also an overhead related to resizing. It's possible and wise to set the capacity upfront, whenever the size of
      list is known.
    - _LinkedList_'s advantage is O(1) appending.
    - The decision whether to use _ArrayList_ of _LinkedList_ should depend on the pattern of access. Inserting to both
      lists is O(1). Adding at an index to _ArrayList_ requires all following elements to be shifted. Getting any
      element from _ArrayList_ is O(1), while _LinkedList_ requires navigating from the beginning. Usually _ArrayList_
      is recommended, unless specific behavior of _LinkedList_ is desired (appending to the beginning/end of the list).
    - _Collections_ class exposes method _synchronizedList()_, which wraps List method invocations in a _synchronized_
      block.
- The main types of map are __HashMap__, __LinkedHashMap__ and __TreeMap__.
    - Two factors impact the performance of _HashMap_: __initialCapacity__ (current number of buckets, defaults to 16)
      and __loadFactor__ (how full the hash table is allowed before the capacity is increased, defaults to 0.75).
      Increasing
      the capacity (twice for JVM) requires rehashing, resulting in performance impact.
    - It's recommended to set the initialCapacity if it's known upfront. It reduces the overhead of automatic rehashing.
      Increasing the loadFactor also reduces rehashing, but makes access slower as map becomes fuller.
    - _HashMap_ provides O(1) _get()_ and _put()_ times. Iterating may be costly and is impacted by initialCapacity and
      loadFactor.
    - When buckets become large there is an additional overhead of searching in them: elements are stored as
      _LinkedList_. Once buckets extends _TREEIFY_THRESHOLD_ it is converted into _TreeNodes_. The disadvantage of
      maintaining _TreeNodes_ is that their size is twice the size of a list nodes.
    - _LinkedHashMap_, a subclass of _HashMap_ maintains the insertion order. It's less costly than using _TreeMap_. The
      need of using _LinkedHashMap_ is low as in Maps order rarely matters.
    - _TreeMap_ is a red-black tree implementation - a binary tree with additional metadata (coloring) preventing trees
      from becoming unbalanced. _TreeMap_ offers quick access to a submap, it's efficient for partitioning the data. It
      offers log(n) performance for _get()_, _put()_, _containsKey()_ and _remove()_ operations.
- The main types of set are __HashSet__, __LinkedHashSet__, __TreeSet__. They are implemented on top of Map equivalents,
  storing elements as keys and an object placeholder as value.
    - _HashSet_ has O(1) insertion, removal and contains operation time, doesn't maintain an ordering of elements.
    - _LinkedHashSet_ maintains an ordering of elements, performance depends on __initialCapacity__ and __loadFactor__.
    - _TreeSet_ is implemented in similar way to _TreeMap_, preserves the natural ordering of elements. It offers log(n)
      performance for insertion, removal and contains operations. For range-based or ordering operations _TreeSet_ is
      efficient.
- Domain objects often cause problems like memory leaks. `jmap -histo` provides a quick insight into the state of Java
  heap for diagnosing them. If domain objects appear in the top 30 entities generated by _jmap_, it's a possible sign of
  memory leak. Leaking domain objects also cause __all generations effect__. When leaking, they live long enough to
  become Tenured and will show up with all possible values for the generational count.
- _finalize()_ in Java was provided for automatic cleanup and resources release when an object is destroyed. It's a
  no-op by default and should remain that way. Objects overriding _finalize()_ are treated specially by the garbage
  collector. They require GC to run again to collect the data, persist for one extra GC cycle, which can be particularly
  painful for Tenured objects. Additionally, when exception is thrown in _finalize()_ method, it's ignored. Finalization
  may contain blocking operations. As JVM creates a thread to run _finalize()_, a significant overhead may occur.
  Finalization has no time guarantee as to when the resource will be released. Oracle's recommendation is to avoid
  finalization.
- __try-with-resource__ is a compiler mechanism. At the first glance it generates a lot of boilerplate. However, it's a
  very useful simplification preventing classes from having to know how to release and clean up. It's a recommended best
  practice.
- _invokedynamic_ call site doesn't determine which method is to be called until runtime. __BSM__ (_bootstrap method_)
  returns an object representing the actual target method. A key concept is the _method handle_, an object representing
  the method which should be called. _java.lang.invoke.MethodHandle_ represents _directly executable_ references to
  methods. These objects contain a group of related methods that allow execution of the underlying methods (like
  _invoke()_). This mechanic is similar in concept to reflection, but contains more advanced features going beyond
  reflective case. The lookup mechanism looks like additional boilerplate, but corrects the biggest problem with
  reflection - access control.

Chapter 12. Concurrent Performance Tuning

- Increase in transistors on a chip, according to Moore's Law, result in more capable processors. But the original
  momentum is hard to maintain. Currently multicore processors are popular and software developers must take advantage
  of distributing computation in their applications. In JVM the benefit is out of the box: even in a single-thread
  applications there are always VM threads, like JIT, running in parallel.
- Amdahl's Law became the main consideration in the multicore environment: total time taken can never be less than the
  serial time. If the serial overhead is 5%, the effective speedup will not be greater than 20X. It's a practical limit
  of software scaling. The usual approach to overcome it is to avoid sharing data between threads. Shared data not only
  add serial synchronization overhead, but also increases complexity. Shared state requires protection and control,
  which in JVM is guaranteed by __Java Memory Model__ (JMM).
- In Java even such a simple operation as incrementing a counter is not a single operation. While analyzing the bytecode
  we can observe that it contains of multiple instructions, like loading, incrementing and storing the value. If the
  operation is not protected by an appropriate lock, load could happen before another thread is stored. As the OS
  scheduler performs context switching at nondeterministic times, different sequences of bytecodes are possible when the
  counter is shared between multiple threads. Each thread have a private evaluation stack, but the operations on fields
  can interfere with each other. Counter is located in the heap, which is shared. The popular misconception is that
  _volatile_ makes the operation safe. But it only forces rereading the value by the cache, any updates will be seen by
  another thread. It doesn't prevent the lost update problem caused by the composite nature of the increment operation.
  It must be protected by _synchronized_ or other locks.
- _synchronized_ keyword can be used to control access to a shared state by multiple threads. However, it requires
  careful design. Synchronization may slow down the program in certain circumstances. It must be performance tested.
- There are two possible approaches to a memory model: __String memory model__, when all cores see the same value all
  the time, or __Weak memory model__, where cores may see different values and there are special cache rules which
  control when this may occur. The problem with strong memory model is that it requires write back to memory and
  notifications of cache invalidation could dominate the memory bus. It's unsuitable for multicore environments.
- JMM has a weak memory model. JMM is also a set of minimal requirements, JVM implementations may implement additional
  rules.
- Locking with synchronization is one of the most important techniques. But this approach is not satisfying for
  developers interested in performance. With synchronization, threads keep their own description of objects' states and
  changes made by threads must be flushed to memory. The main idea of synchronization is that the local view of the
  object's state hast to be synchronized with the main memory. To make this approach successful both read and write
  access must be synchronized. Synchronization only on write operations could lead to lost updates.
- _synchronized_ lock has its limitations: all synchronized operations are treated equally, synchronization is performed
  on the method level or _synchronized_ block, lock is acquired or the thread is blocked: no way to continue processing
  if the lock cannot be obtained.
- Intrinsic locking approach (described above) is not flexible. Modern versions of Java move away from language-level
  support in favor of standard library (`java.util.concurrent`). Locks and atomics in this library relay heavily on
  low-level processor instructions implementing __Compare and Swap__ (CAS) technique. Access to CAS is exposed
  via `sun.misc.Unsafe` class, which is an internal implementation class and is not part of the standard API. It's
  design to break the standard behavior of the JVM.
- Atomics do not inherit from the base type they wrap. These are lock-free classes, resilient to deadlock.
- Intrinsic locks work by invoking the operation system in user code. OS may add significant overhead when putting a
  thread in an indefinite wait state until signaled. This may seem like a resource waste if the access to resource
  happens in a short period of time. Sometimes it could be more efficient to keep the waiting thread active on a CPU
  instead of performing the context switching. Such technique is called a __spinlock__. Spinlocks are usually
  implemented with CAS.
- The implementations of `java.util.concurrent.locks.Lock` give more possibilities and are more flexible than intrinsic
  locks, for example they can be acquired in one method and unlocked in another. They allow creating _re-entrant locks_
  preventing a thread from blocking itself.
- Usually we can observe a disproportion between number of read and write operations. `ReadLock` and `WriteLock` can be
  used in such cases. Using them allows multiple reading threads not causing other reading threads to block. But the
  write operation will block.
- Semaphores allow X objects to access a specific resource. The interface is `Semaphore::acquire()`
  and `Semaphore::release()`. A one-permit semaphore is equivalent to a mutex. The difference is that the semaphore can
  only be released by a thread that holds the lock, while semaphore can be released by other thread.
- `ConcurrentHashMap` is split into segments, each having its own locking policy and read/write lock access. Iterators
  are acquired on a snapshot, they will not throw a _ConcurrentModificationException_.
- _CopyOnWriteArrayList_ and _CopyOnWriteArraySet_ were introduced in Java 5 ensuring that any mutation of the data
  structure result in a fresh copy. Existing iterators can continue iterating over the old array, there is no
  _ConcurrentModificationException_ thrown.
- __Latches__ ensure that when their count will reach 0 and all threads held on the _await()_ will be released to
  continue processing. Latches cannot be reused, their countdown value cannot be re-set.
- _Runnable_ doesn't return a result and doesn't throw exceptions. If an exception is thrown from _Runnable_ it is
  propagated up the stack and the executing thread stops running.
- _ExecutionService_ defines a mechanism for executing tasks on a pool of threads. There are factory methods to create
  them in _Executors_ class. Using managed threads helps to avoid costly thread creation for each task. The _submit()_
  call to ExecutorService returns a _Future<V>_, which allows blocking _get()_ operation. Threads in ExecutorServices
  can be customized with _ThreadFactory_.
- _Fork/Join framework_ allows developer not to manage their threads. To use the framework there is a new
  implementation (since Java 7) of ExecutorService, called _ForkJoinPool_. _ForkJoinTask_ is more lightweight than a
  Thread. It can be subdivided into smaller tasks. Fork/Join framework is suitable only for certain types of tasks.
  Fork/Join framework also uses the __work stealing__ approach, which can be used independently of tasks subdivision.
  Usually the sizing pool is __availableProcessor - 1__, but it not always uses the expected value: it's OS and hardware
  dependent. The parallelism factor can also be changed using a JVM flag.
- One of the modern approaches to multithreading is the use of _parallelStream()_. It's tempting but the benefit should
  be measured, as in some circumstances (smaller collections) serial computation can be faster.

## Modern Software Engineering: Doing What Works to Build Better Software Faster (ISBN: 978-0-13-731491-1)

1 Introduction

- Software development is a process of continuous discovery and exploration. And humanity's best approach to learning is
  science. For this reason we should approach software development the scientific way:
    - Observe the current state,
    - Describe and explain observations,
    - Make predictions,
    - Test predictions.
- Software engineering is applying the scientific approach to find efficient solutions to problems in software.
- We must become expects in learning and complexity management. Our approach to creating complex systems should be
  evolutionary. We should make progress even when answers or direction is uncertain.
- Engineering in general means "stuff that works".
- Software development is one of the more complex activities that we undertake. We have learned and keep learning
  continuously what works and what doesn't. We should make progress on the shoulder of giants. This approach is science
  and the scientific way of solving practical problems is engineering.
- It's important to have the _paradigm shift_ approach, be ready to fundamentally change the perspective on something.
  It allows us to learn new things, but that also means discarding what was before if it is no longer correct. Such
  mindset allows us to build more effectively and discard bad ideas more efficiently.

# Projects

## Equino

- Equino Kubernetes cluster monitoring was [set up](https://github.com/marcinciapa/equino-kubernetes/pull/7).

## ACTracker

- GET API for entities was [introduced](https://github.com/marcinciapa/actracker-api/pull/161) in actracker-api.
- JPA module was [split to smaller modules](https://github.com/marcinciapa/actracker-api/pull/163) in actracker-api.
- JPA metamodel was [introduced](https://github.com/marcinciapa/actracker-api/pull/166) in actracker-api.
- Access to actracker-api endpoints was [restricted](https://github.com/marcinciapa/equino-kubernetes/pull/8) in
  Kubernetes ingress. New path to actracker-api was [exposed](https://github.com/marcinciapa/actracker-api/pull/167)
  and [consumed](https://github.com/marcinciapa/actracker-ui/pull/66) by actracker-ui.

# Tutorials

- Microservices and Distributed Systems: [Bootstrap with Maven](https://github.com/marcinciapa/tutorials/pull/10)
- Microservices and Distributed Systems: [Your First Microservice](https://github.com/marcinciapa/tutorials/pull/11)
- Microservices and Distributed Systems:
  [Microservice Communication via HTTP](https://github.com/marcinciapa/tutorials/pull/12)
- Microservices and Distributed Systems: [Open Feign](https://github.com/marcinciapa/tutorials/pull/14)
- Microservices and Distributed Systems: [Exercise](https://github.com/marcinciapa/tutorials/pull/16)
- Microservices and Distributed Systems: [Distributed Tracing](https://github.com/marcinciapa/tutorials/pull/17)
- Microservices and Distributed Systems:
  [Api Gateway With Spring Cloud Gateway](https://github.com/marcinciapa/tutorials/pull/18)
- Microservices and Distributed Systems: [Message Queues](https://github.com/marcinciapa/tutorials/pull/19)
- Microservices and Distributed Systems: [RabbitMQ](https://github.com/marcinciapa/tutorials/pull/20)
- Microservices and Distributed Systems:
  [Packaging Microservices to Runnable Jar](https://github.com/marcinciapa/tutorials/pull/21)
- Microservices and Distributed Systems:
  [Packaging Jars to Docker Images](https://github.com/marcinciapa/tutorials/pull/22)
- Microservices and Distributed Systems: [Kubernetes AKA k8s](https://github.com/marcinciapa/tutorials/pull/23)
- Microservices and Distributed Systems:
  [Deploying Postgres RabbitMQ and Zipkin to k8s](https://github.com/marcinciapa/tutorials/pull/24)
- Microservices and Distributed Systems:
  [Refactoring Microservices for k8s](https://github.com/marcinciapa/tutorials/pull/25)
- Microservices and Distributed Systems:
  [Deploying Microservices to k8s](https://github.com/marcinciapa/tutorials/pull/26)
- Microservices and Distributed Systems:
  [Managed Kubernetes Cluster with Linode](https://github.com/marcinciapa/tutorials/pull/27)
- Microservices and Distributed Systems: [Kafka](https://github.com/marcinciapa/tutorials/pull/28)
- Microservices and Distributed Systems:
  [Bringing Back API Gateway for Security](https://github.com/marcinciapa/tutorials/pull/29)
- Microservices and Distributed Systems:
  [Security - API Key Authentication](https://github.com/marcinciapa/tutorials/pull/30)
- Microservices and Distributed Systems: [Outro](https://github.com/marcinciapa/tutorials/pull/31)